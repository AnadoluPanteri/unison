
**********
globals.ml :
**********

delete mergeable

let separator = '>'

(* divide the string *)
let divide s =
  if String.contains s separator then
    let i = String.index s separator in
    let n = String.length s in
    try 
    (Path.fromString (String.sub s 0 i),String.sub s (i+1) (n-i-1))
    with _ -> assert false
  else raise (Util.Fatal (Printf.sprintf
                  "The merge pref only contains a Path '%s' without specifying a command"
                  s))

let merge= 
  Prefs.create "merge" []
    "program to use to merge the corresponding files"
    ("This preference can be used to run a merge program which will create "
     ^ "a new version for each of the files and the backup, "
     ^ "with the last backup and the both replicas."
     ^ "The syntax of \\ARG{pathspec>cmd} is "
     ^ "described in \\sectionref{pathspec}{Path Specification}, and further "
     ^ "details on Merging functions are present in "
     ^ "\\sectionref{merge}{Merging files}")
    (fun oldpaths string -> Safelist.append oldpaths [divide string])
    (fun l -> Safelist.map (fun x ->(Path.toString (fst x))) l)

let shouldMerge p=
  let pref = Safelist.map fst (Prefs.read merge) in
  let spec = Rx.alt (Safelist.map Pred.compile_pattern (Safelist.map Path.toString pref)) in
  Rx.match_string spec p

let assocMerge p=
  let pref = Safelist.map (fun (p,c)->(Pred.compile_pattern(Path.toString p),c)) (Prefs.read merge) in
  let rec loop l p= match l with
      [] -> "" (* Should be an error or a none *)
    | (spec,cmd)::_ when (Rx.match_string spec p) -> cmd
    | _::q -> loop q p in
  loop pref p


***********
globals.mli :
***********

val merge : (Path.t * string ) list Prefs.t
val assocMerge : string -> string
val shouldMerge : string -> bool



*********
files.ml :
*********

delete merge and merge3

let formatMergeCmd p f1 f2 backup out1 out2 outarch =
  let longMerge = ref true in
  let raw = if Globals.shouldMerge p then
    Globals.assocMerge p 
  else "" in
  let raw2 = Prefs.read merge2 in
  let raw = match backup with
      None -> if raw2="" then raise
                  (Util.Transient "Preference 'merge2' must be set")
              else (longMerge := false;raw2)
    | Some _ -> if raw="" then raise
                  (Util.Transient "Preference 'merge' or 'merge2' must be set")
                else raw in
  let cooked = Util.replacesubstring raw    "CURRENT1" f1  in
  let cooked = Util.replacesubstring cooked "CURRENT2" f2  in
  let cooked =
    match backup with
	None -> cooked
      | Some(s) -> 
	  if !longMerge then begin
	    let cooked = Util.replacesubstring cooked "NEW1"     out1 in
	    let cooked = Util.replacesubstring cooked "NEW2"     out2 in
	    let cooked = Util.replacesubstring cooked "NEWARCH"  outarch in
	      Util.replacesubstring cooked "OLD" s 
	  end
	  else
	    Util.replacesubstring cooked "OLD" s
  in
  let cooked = Util.replacesubstring cooked "NEW"      out1 in
    (cooked,!longMerge)
    
l851
formatMergeCmd (Path.toString path)
	...
l918
Globals.shouldMerge (Path.toString path)

l945
Globals.shouldMerge (Path.toString path) 


*********
recon.ml : 
*********
l22
Globals.shouldMerge (Path.toString ri.path)

l379
Globals.shouldMerge (Path.toString path)

***********
update.ml :
***********
l1012
(Globals.shouldMerge (Path.toString mirrorPath))

l1094
(Globals.shouldMerge (Path.toString pathFrom))

l1139
(Globals.shouldMerge (Path.toString realPath))





